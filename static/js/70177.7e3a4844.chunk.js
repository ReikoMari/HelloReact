"use strict";(self.webpackChunkhelloworld=self.webpackChunkhelloworld||[]).push([[70177],{37923:(e,t,n)=>{n.d(t,{C:()=>H,b:()=>V});var o,i,r,a,s,l,c,d,p,u,f=n(57528),h=n(72412),v=n(34981),g=n(26917),m=n(59395),y=n(90080),A=n(54478),O=n(49399),x=n(48020),C=n(81993),b=n(66763),S=n(90235),P=n(80883),w=n(3799),T=n(58350),_=n(64839),E=n(32307),z=n(10773),D=n(66470);function V(e){const t=new E.N5,{vertex:n,fragment:V,attributes:H,varyings:R}=t;(0,w.NB)(n,e),t.include(m.d,e),t.include(A.c,e),t.include(b.A,e),t.include(y.g,e),H.add(D.r.POSITION,"vec3"),e.vvColor&&H.add(D.r.COLORFEATUREATTRIBUTE,"float"),R.add("vColor","vec4"),R.add("vpos","vec3");const I=e.multipassEnabled&&(e.output===v.V.Color||e.output===v.V.Alpha);I&&R.add("depth","float"),n.uniforms.add(new T.E("eColor",(e=>e.color)));const N=e.output===v.V.LinearDepth;N&&(t.include(O.L,e),(0,h.xJ)(t),(0,h.Mu)(t)),n.code.add((0,_.H)(o||(o=(0,f.A)(["\n    void main(void) {\n      vpos = position;\n      forwardNormalizedVertexColor();\n      forwardObjectAndLayerIdColor();\n\n      ","\n      ","\n      gl_Position = ","\n    }\n  "])),e.hasVertexColors?"vColor *= eColor;":e.vvColor?"vColor = eColor * interpolateVVColor(colorFeatureAttribute);":"vColor = eColor;",I?"depth = (view * vec4(vpos, 1.0)).z;":"",N?(0,_.H)(i||(i=(0,f.A)(["transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);"]))):(0,_.H)(r||(r=(0,f.A)(["transformPosition(proj, view, vpos);"]))))),t.include(g.HQ,e),I&&t.include(C.Q,e),V.include(P.a);const j=e.output===v.V.Highlight;return j&&t.include(x.Qh,e),V.code.add((0,_.H)(a||(a=(0,f.A)(["\n  void main() {\n    discardBySlice(vpos);\n    ","\n    vec4 fColor = vColor;\n\n    ","\n\n    if (fColor.a < ",") {\n      discard;\n    }\n\n    ","\n\n    ","\n    ",";\n    ",";\n    ","\n  }\n  "])),I?"terrainDepthTest(depth);":"",e.output===v.V.ObjectAndLayerIdColor?(0,_.H)(s||(s=(0,f.A)(["fColor.a = 1.0;"]))):"",_.H.float(S.y),e.output===v.V.Alpha?(0,_.H)(l||(l=(0,f.A)(["fragColor = vec4(fColor.a);"]))):"",e.output===v.V.Color?(0,_.H)(c||(c=(0,f.A)(["fragColor = highlightSlice(fColor, vpos); ",""])),e.transparencyPassType===z.y.Color?"fragColor = premultiplyAlpha(fragColor);":""):"",j?(0,_.H)(d||(d=(0,f.A)(["outputHighlight();"]))):"",e.output===v.V.LinearDepth?(0,_.H)(p||(p=(0,f.A)(["outputDepth(linearDepth);"]))):"",e.output===v.V.ObjectAndLayerIdColor?(0,_.H)(u||(u=(0,f.A)(["outputObjectAndLayerIdColor();"]))):"")),t}const H=Object.freeze(Object.defineProperty({__proto__:null,build:V},Symbol.toStringTag,{value:"Module"}))},19061:(e,t,n)=>{n.d(t,{H:()=>te,b:()=>J,c:()=>K});var o,i,r,a,s,l,c,d,p,u,f,h,v,g,m,y,A,O,x,C,b,S,P=n(57528),w=n(19555),T=n(72745),_=n(55855),E=n(34981),z=n(26917),D=n(90080),V=n(98720),H=n(40318),R=n(38280),I=n(62374),N=n(48020),j=n(66763),F=n(90235),L=n(80883),U=n(81449),W=n(69817),M=n(3799),B=n(95756),G=n(58350),k=n(21390),q=n(64839),Y=n(32307),Q=n(70367),Z=n(10773),X=n(66470);function J(e){const t=new Y.N5,n=e.signedDistanceFieldEnabled;if(t.include(H.Q,e),t.include(z.HQ,e),e.occlusionPass)return t.include(R.I,e),t;const{vertex:T,fragment:J}=t;t.include(W.Y6),J.include(U.W),J.include(L.a),t.include(j.A,e),t.include(D.g,e),t.include(I.y),t.varyings.add("vcolor","vec4"),t.varyings.add("vtc","vec2"),t.varyings.add("vsize","vec2"),t.varyings.add("voccluded","float"),T.uniforms.add(new G.E("viewport",((e,t)=>t.camera.fullViewport)),new B.G("screenOffset",((e,t)=>(0,w.hZ)(ee,2*e.screenOffset[0]*t.camera.pixelRatio,2*e.screenOffset[1]*t.camera.pixelRatio))),new B.G("anchorPosition",(e=>K(e))),new G.E("materialColor",(e=>e.color))),(0,M.Nz)(T),n&&(T.uniforms.add(new G.E("outlineColor",(e=>e.outlineColor))),J.uniforms.add(new G.E("outlineColor",(e=>$(e)?e.outlineColor:_.uY)),new k.m("outlineSize",(e=>$(e)?e.outlineSize:0)))),e.pixelSnappingEnabled&&T.include(V.K),e.hasScreenSizePerspective&&((0,W.pM)(T),(0,W.OH)(T)),e.debugDrawLabelBorder&&t.varyings.add("debugBorderCoords","vec4"),t.attributes.add(X.r.UV0,"vec2"),t.attributes.add(X.r.COLOR,"vec4"),t.attributes.add(X.r.SIZE,"vec2"),t.attributes.add(X.r.FEATUREATTRIBUTE,"vec4"),T.code.add((0,q.H)(o||(o=(0,P.A)(["\n    void main(void) {\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      forwardObjectAndLayerIdColor();\n\n      if (rejectBySlice(projectAux.posModel)) {\n        // Project outside of clip plane\n        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n        return;\n      }\n      vec2 inputSize;\n      ","\n\n      ","\n\n      vec2 combinedSize = inputSize * pixelRatio;\n      vec4 quadOffset = vec4(0.0);\n      bool visible = testHUDVisibility(posProj);\n      voccluded = visible ? 0.0 : 1.0;\n    "])),e.hasScreenSizePerspective?(0,q.H)(i||(i=(0,P.A)(["\n            inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n            vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n         "]))):(0,q.H)(r||(r=(0,P.A)(["\n            inputSize = size;\n            vec2 screenOffsetScaled = screenOffset;"]))),e.vvSize?"inputSize *= vvScale(featureAttribute).xx;":""));const te=(0,q.H)(a||(a=(0,P.A)(["vec2 uv01 = floor(uv0);\nvec2 uv = uv0 - uv01;\nquadOffset.xy = ((uv01 - anchorPosition) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;"]))),ne=e.pixelSnappingEnabled?n?(0,q.H)(s||(s=(0,P.A)(["posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;"]))):(0,q.H)(l||(l=(0,P.A)(["posProj += quadOffset;\nif (inputSize.x == size.x) {\nposProj = alignToPixelOrigin(posProj, viewport.zw);\n}"]))):(0,q.H)(c||(c=(0,P.A)(["posProj += quadOffset;"])));T.code.add((0,q.H)(d||(d=(0,P.A)(["\n    ","\n    ","\n    ","\n\n    ","\n\n    bool alphaDiscard = vcolor.a < ",";\n    ",'\n    if (alphaDiscard) {\n      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    } else {\n      ',"\n      gl_Position = posProj;\n    }\n\n    vtc = uv;\n\n    ","\n    vsize = inputSize;\n    ","\n  }\n  "])),e.occlusionTestEnabled?"if (visible) {":"",te,e.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;",e.output===E.V.ObjectAndLayerIdColor?(0,q.H)(p||(p=(0,P.A)(["vcolor.a = 1.0;"]))):"",q.H.float(F.y),n?"alphaDiscard = alphaDiscard && outlineColor.a < ".concat(q.H.float(F.y),";"):"",ne,e.debugDrawLabelBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":"",e.occlusionTestEnabled?(0,q.H)(u||(u=(0,P.A)(["} else { vtc = vec2(0.0);\n      ",""])),e.debugDrawLabelBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"):"")),J.uniforms.add(new Q.N("tex",(e=>e.texture)));const oe=e.debugDrawLabelBorder?(0,q.H)(f||(f=(0,P.A)(["(isBorder > 0.0 ? 0.0 : ",")"])),q.H.float(F.H)):q.H.float(F.H),ie=(0,q.H)(h||(h=(0,P.A)(["\n    ","\n\n    ","\n\n    ","\n\n    // Draw debug border with transparency, so that original texels along border are still partially visible\n    ","\n  "])),e.debugDrawLabelBorder?(0,q.H)(v||(v=(0,P.A)(["\n      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));"]))):"",e.sampleSignedDistanceFieldTexelCenter?(0,q.H)(g||(g=(0,P.A)(["\n      // Attempt to sample texel centers to avoid that thin cross outlines\n      // disappear with large symbol sizes.\n      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n      float txSize = float(textureSize(tex, 0).x);\n      float texelSize = 1.0 / txSize;\n\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\n      "]))):(0,q.H)(m||(m=(0,P.A)(["\n      vec2 samplePos = vtc;\n      "]))),n?(0,q.H)(y||(y=(0,P.A)(["\n      vec4 fillPixelColor = vcolor;\n\n      // Get distance and map it into [-0.5, 0.5]\n      float d = rgba2float(texture(tex, samplePos)) - 0.5;\n\n      // Distance in output units (i.e. pixels)\n      float dist = d * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < "," ||\n          fillPixelColor.a + outlinePixelColor.a < ","\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        fragColor = vec4(compositeColor, compositeAlpha);\n      } else {\n        if (fillAlphaFactor < ",") {\n          discard;\n        }\n\n        fragColor = premultiplyAlpha(fillPixelColor);\n      }\n\n      // visualize SDF:\n      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      "])),oe,q.H.float(F.y),oe):(0,q.H)(A||(A=(0,P.A)(["\n          vec4 texColor = texture(tex, vtc, -0.5);\n          if (texColor.a < ",") {\n            discard;\n          }\n          fragColor = texColor * premultiplyAlpha(vcolor);\n          "])),oe),e.debugDrawLabelBorder?(0,q.H)(O||(O=(0,P.A)(["fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);"]))):"");switch(e.output){case E.V.Color:J.code.add((0,q.H)(x||(x=(0,P.A)(["\n        void main() {\n          ","\n          ","\n        }"])),ie,e.transparencyPassType===Z.y.FrontFace?"fragColor.rgb /= fragColor.a;":""));break;case E.V.Alpha:J.code.add((0,q.H)(C||(C=(0,P.A)(["\n        void main() {\n          ","\n          fragColor = vec4(fragColor.a);\n        }"])),ie));break;case E.V.ObjectAndLayerIdColor:J.code.add((0,q.H)(b||(b=(0,P.A)(["\n        void main() {\n          ","\n          outputObjectAndLayerIdColor();\n        }"])),ie));break;case E.V.Highlight:J.constants.add("occludedHighlightFlag","vec4",N.U),J.constants.add("unoccludedHighlightFlag","vec4",N.bO),J.code.add((0,q.H)(S||(S=(0,P.A)(["\n        void main() {\n          ","\n          if (voccluded == 1.0) {\n            fragColor = occludedHighlightFlag;\n          } else {\n            fragColor = unoccludedHighlightFlag;\n          }\n        }"])),ie))}return t}function $(e){return e.outlineColor[3]>0&&e.outlineSize>0}function K(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ee;return e.textureIsSignedDistanceField?function(e,t,n){null!=t?(0,w.hZ)(n,e[0]*(t[2]-t[0])+t[0],e[1]*(t[3]-t[1])+t[1]):(0,w.hZ)(n,0,0)}(e.anchorPosition,e.distanceFieldBoundingBox,t):(0,w.C)(t,e.anchorPosition),t}const ee=(0,T.vt)(),te=Object.freeze(Object.defineProperty({__proto__:null,build:J,calculateAnchorPosForRendering:K},Symbol.toStringTag,{value:"Module"}))},36423:(e,t,n)=>{n.d(t,{$2:()=>P,$C:()=>O,Hj:()=>b,Mh:()=>S,W$:()=>g,eA:()=>x,pW:()=>C,t8:()=>A,vY:()=>w});var o=n(31633),i=n(34761),r=n(13191),a=n(9392),s=n(43047),l=n(55855),c=n(9624),d=n(42294),p=n(2413),u=n(205),f=n(5262),h=n(18117),v=n(32535);function g(e,t){if("point"===e.type)return y(e,t,!1);if((0,v.gr)(e))switch(e.type){case"extent":return y(e.center,t,!1);case"polygon":return y(e.centroid,t,!1);case"polyline":return y(m(e),t,!0);case"mesh":return y(e.origin,t,!1)}else switch(e.type){case"extent":return y(function(e){return(0,h.T)(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),null!=e.zmin&&null!=e.zmax&&isFinite(e.zmin)&&isFinite(e.zmax)?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return y(function(e){const t=e.rings[0];if(!t||0===t.length)return null;const n=(0,u.S8)(e.rings,!!e.hasZ);return(0,h.T)(n[0],n[1],n[2],e.spatialReference)}(e),t,!0);case"polyline":return y(m(e),t,!0)}}function m(e){const t=e.paths[0];if(!t||0===t.length)return null;const n=(0,f.$H)(t,(0,f.Yl)(t)/2);return(0,h.T)(n[0],n[1],n[2],e.spatialReference)}function y(e,t,n){const o=n?e:(0,v.EL)(e);return t&&e?(0,c.projectPoint)(e,o,t)?o:null:o}function A(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(e){t||(t=(0,p.vt)());const i=e;let r=.5*i.width*(n-1),a=.5*i.height*(n-1);return i.width<1e-7*i.height?r+=a/20:i.height<1e-7*i.width&&(a+=r/20),(0,s.s)(t,i.xmin-r-o,i.ymin-a-o,i.xmax+r+o,i.ymax+a+o),t}return null}function O(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const o=(0,l.o8)(l.Un);return null!=e&&(o[0]=e[0],o[1]=e[1],o[2]=e[2]),null!=t?o[3]=t:null!=e&&e.length>3&&(o[3]=e[3]),n&&(o[0]*=n,o[1]*=n,o[2]*=n,o[3]*=n),o}function x(e,t,n,o,i){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[0,0,0,0];for(let a=0;a<3;++a)r[a]=null!=(null===e||void 0===e?void 0:e[a])?e[a]:null!=(null===n||void 0===n?void 0:n[a])?n[a]:i[a];return r[3]=null!=t?t:null!=o?o:i[3],r}function C(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.Un,t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const i=new Array(3);if(null==t||null==n)i[0]=1,i[1]=1,i[2]=1;else{let o,r=0;for(let a=2;a>=0;a--){const s=e[a];let l;const c=null!=s,d=0===a&&!o&&!c,p=n[a];"symbol-value"===s||d?l=0!==p?t[a]/p:1:c&&"proportional"!==s&&isFinite(s)&&(l=0!==p?s/p:1),null!=l&&(i[a]=l,o=l,r=Math.max(r,Math.abs(l)))}for(let e=2;e>=0;e--)null==i[e]?i[e]=o:0===i[e]&&(i[e]=.001*r)}for(let r=2;r>=0;r--)i[r]/=o;return(0,a.ci)(i)}function b(e){return S(function(e){return null!=e.isPrimitive}(e)?[e.width,e.depth,e.height]:e)?null:"Symbol sizes may not be negative values"}function S(e){const t=e=>null==e||e>=0;return Array.isArray(e)?e.every(t):t(e)}function P(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:(0,r.vt)();return e&&(0,i.Qr)(o,o,-e/180*Math.PI),t&&(0,i.eL)(o,o,t/180*Math.PI),n&&(0,i.Z8)(o,o,n/180*Math.PI),o}function w(e,t,n){if(null!=n.minDemResolution)return n.minDemResolution;const i=(0,o.GA)(t),r=(0,d.VL)(e)*i,a=(0,d.yr)(e)*i,s=(0,d.uJ)(e)*(t.isGeographic?1:i);return 0===r&&0===a&&0===s?n.minDemResolutionForPoints:.01*Math.max(r,a,s)}},98720:(e,t,n)=>{n.d(t,{K:()=>l});var o,i,r=n(57528),a=n(53736),s=n(64839);function l(e){e.uniforms.add(new a.e("alignPixelEnabled",((e,t)=>t.alignPixelEnabled))),e.code.add((0,s.H)(o||(o=(0,r.A)(["vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}"])))),e.code.add((0,s.H)(i||(i=(0,r.A)(["vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}"]))))}},40318:(e,t,n)=>{n.d(t,{Q:()=>A,R:()=>y});var o,i,r,a,s,l,c,d=n(57528),p=n(25530),u=n(69817),f=n(3799),h=n(58350),v=n(21390),g=n(64839),m=n(66470);const y=.5;function A(e,t){e.include(u.Y6),e.attributes.add(m.r.POSITION,"vec3"),e.attributes.add(m.r.NORMAL,"vec3"),e.attributes.add(m.r.CENTEROFFSETANDDISTANCE,"vec4");const n=e.vertex;(0,f.NB)(n,t),(0,f.yu)(n,t),n.uniforms.add(new h.E("viewport",((e,t)=>t.camera.fullViewport)),new v.m("polygonOffset",(e=>e.shaderPolygonOffset)),new v.m("cameraGroundRelative",((e,t)=>t.camera.aboveGround?1:-1))),t.hasVerticalOffset&&(0,p.V)(n),n.constants.add("smallOffsetAngle","float",.984807753012208),n.code.add((0,g.H)(o||(o=(0,d.A)(["struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};"])))),n.code.add((0,g.H)(i||(i=(0,d.A)(["\n    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n      float pointGroundSign = ",";\n      if (pointGroundSign == 0.0) {\n        pointGroundSign = cameraGroundRelative;\n      }\n\n      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\n      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\n      float groundRelative = cameraGroundRelative * pointGroundSign;\n\n      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is\n      // dropped is instead introduced using the ground-relative position of the symbol and the camera\n      if (polygonOffset > .0) {\n        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n        float factor = (1.0 - tanAlpha / viewport[2]);\n\n        // same side of the terrain\n        if (groundRelative > 0.0) {\n          posView *= factor;\n        }\n        // opposite sides of the terrain\n        else {\n          posView /= factor;\n        }\n      }\n\n      return groundRelative;\n    }\n  "])),t.multipassEnabled?g.H.float(0):(0,g.H)(r||(r=(0,d.A)(["sign(pointGroundDistance)"]))))),t.draped&&!t.hasVerticalOffset||(0,f.S7)(n),t.draped||(n.uniforms.add(new v.m("perDistancePixelRatio",((e,t)=>Math.tan(t.camera.fovY/2)/(t.camera.fullViewport[2]/2)))),n.code.add((0,g.H)(a||(a=(0,d.A)(["\n    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n      float distanceToCamera = length(posView);\n\n      // Compute offset in world units for a half pixel shift\n      float pixelOffset = distanceToCamera * perDistancePixelRatio * ",";\n\n      // Apply offset along normal in the direction away from the ground surface\n      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n\n      // Apply the same offset also on the view space position\n      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n\n      posModel += modelOffset;\n      posView += viewOffset;\n    }\n  "])),g.H.float(y)))),t.screenCenterOffsetUnitsEnabled&&(0,f.Nz)(n),t.hasScreenSizePerspective&&(0,u.OH)(n),n.code.add((0,g.H)(s||(s=(0,d.A)(["\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      vec3 centerOffset = centerOffsetAndDistance.xyz;\n      float pointGroundDistance = centerOffsetAndDistance.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ","\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ","\n\n      ","\n\n      ","\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ","\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ","\n\n      ","\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  "])),t.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);",t.hasScreenSizePerspective&&(t.hasVerticalOffset||t.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":"",t.hasVerticalOffset?t.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":"",t.hasVerticalOffset?(0,g.H)(l||(l=(0,d.A)(["\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;"]))):"",t.screenCenterOffsetUnitsEnabled?"":(0,g.H)(c||(c=(0,d.A)(["\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          "]))),t.screenCenterOffsetUnitsEnabled?t.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":"",t.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""))}},38280:(e,t,n)=>{n.d(t,{I:()=>u});var o,i,r,a,s=n(57528),l=n(98720),c=n(10708),d=n(81993),p=n(64839);function u(e,t){const{vertex:n,fragment:u}=e;n.include(l.K),t.multipassEnabled&&(n.include(c.H),e.varyings.add("depth","float")),n.code.add((0,p.H)(o||(o=(0,s.A)(["\n  void main(void) {\n    vec4 posProjCenter;\n    if (dot(position, position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel filtering to affect the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n\n      ","\n\n      ","\n      vec3 vpos = projectAux.posModel;\n      if (rejectBySlice(vpos)) {\n        // Project out of clip space\n        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n      }\n\n    } else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n  "])),t.multipassEnabled?(0,p.H)(i||(i=(0,s.A)(["\n        // Don't draw vertices behind geometry\n        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){\n          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n        }"]))):"",t.multipassEnabled?"depth = projectAux.posView.z;":"")),e.include(d.Q,t),u.code.add((0,p.H)(r||(r=(0,s.A)(["\n  void main() {\n    fragColor = vec4(1);\n    ","\n  }\n  "])),t.multipassEnabled?(0,p.H)(a||(a=(0,s.A)(["\n        if(terrainDepthTest(depth)) {\n          fragColor.g = 0.5;\n        }"]))):""))}},62374:(e,t,n)=>{n.d(t,{y:()=>p});var o,i=n(57528),r=n(98720),a=n(98521),s=n(58350),l=n(21390),c=n(64839),d=n(70367);function p(e){e.vertex.uniforms.add(new l.m("renderTransparentlyOccludedHUD",((e,t)=>t.hudRenderStyle===a.D.Occluded?1:t.hudRenderStyle===a.D.NotOccluded?0:.75)),new s.E("viewport",((e,t)=>t.camera.fullViewport)),new d.N("hudVisibilityTexture",((e,t)=>{var n;return null===(n=t.hudVisibility)||void 0===n?void 0:n.getTexture()}))),e.vertex.include(r.K),e.vertex.code.add((0,c.H)(o||(o=(0,i.A)(["bool testHUDVisibility(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (renderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}"]))))}},76956:(e,t,n)=>{n.d(t,{v:()=>E});var o=n(81806),i=n(55855),r=n(48549),a=n(34981),s=n(83490),l=n(59696),c=n(60322),d=n(77730),p=n(66470),u=n(82809),f=n(63928),h=n(93684),v=n(16506),g=n(42693),m=n(32119),y=n(28584),A=n(96643),O=n(10773),x=n(37923),C=n(57162);h.S;class b extends g.w{initializeProgram(e){return new y.B(e.rctx,b.shader.get().build(this.configuration),m.D)}_createPipeline(e,t){const n=this.configuration,o=e===O.y.NONE,i=e===O.y.FrontFace;return(0,C.Ey)({blending:n.output!==a.V.Color&&n.output!==a.V.Alpha||!n.transparent?null:o?c.V0:(0,c.ez)(e),culling:(0,C.Xt)(n.cullFace),depthTest:n.draped?null:{func:(0,c.K_)(e)},depthWrite:n.draped?null:(o||i)&&n.writeDepth?C.kn:null,colorWrite:C.wE,stencilWrite:n.hasOccludees?A.v0:null,stencilTest:n.hasOccludees?t?A.a9:A.qh:null,polygonOffset:o||i?n.polygonOffset?S:null:(0,c.aB)(n.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipeline(e){return e?this._occludeePipelineState:super.getPipeline()}}b.shader=new v.$(x.C,(()=>n.e(35837).then(n.bind(n,35837))));const S={factor:1,units:1};var P=n(35143),w=n(99415),T=n(92656);class _ extends T.E{constructor(){super(...arguments),this.output=a.V.Color,this.cullFace=s.s2.None,this.transparencyPassType=O.y.NONE,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.objectAndLayerIdColorInstanced=!1,this.vvColor=!1,this.draped=!1}}(0,P._)([(0,w.W)({count:a.V.COUNT})],_.prototype,"output",void 0),(0,P._)([(0,w.W)({count:s.s2.COUNT})],_.prototype,"cullFace",void 0),(0,P._)([(0,w.W)({count:O.y.COUNT})],_.prototype,"transparencyPassType",void 0),(0,P._)([(0,w.W)()],_.prototype,"hasSlicePlane",void 0),(0,P._)([(0,w.W)()],_.prototype,"hasVertexColors",void 0),(0,P._)([(0,w.W)()],_.prototype,"transparent",void 0),(0,P._)([(0,w.W)()],_.prototype,"polygonOffset",void 0),(0,P._)([(0,w.W)()],_.prototype,"enableOffset",void 0),(0,P._)([(0,w.W)()],_.prototype,"writeDepth",void 0),(0,P._)([(0,w.W)()],_.prototype,"hasOccludees",void 0),(0,P._)([(0,w.W)()],_.prototype,"multipassEnabled",void 0),(0,P._)([(0,w.W)()],_.prototype,"cullAboveGround",void 0),(0,P._)([(0,w.W)()],_.prototype,"objectAndLayerIdColorInstanced",void 0),(0,P._)([(0,w.W)()],_.prototype,"vvColor",void 0),(0,P._)([(0,w.W)()],_.prototype,"draped",void 0),(0,P._)([(0,w.W)({constValue:!1})],_.prototype,"occlusionPass",void 0),(0,P._)([(0,w.W)({constValue:!0})],_.prototype,"hasVvInstancing",void 0),(0,P._)([(0,w.W)({constValue:!1})],_.prototype,"vvSize",void 0),(0,P._)([(0,w.W)({constValue:!1})],_.prototype,"vvOpacity",void 0);class E extends f.W{constructor(e){super(e,new D),this.supportsEdges=!0,this.produces=new Map([[d.N.OPAQUE_MATERIAL,e=>e===a.V.Highlight||(0,a.BF)(e)&&!this._isTransparent],[d.N.OPAQUE_NO_SSAO_DEPTH,e=>e===a.V.LinearDepth&&this.parameters.writeLinearDepth&&!this._isTransparent],[d.N.TRANSPARENT_MATERIAL,e=>(0,a.BF)(e)&&this._isTransparent&&this.parameters.writeDepth],[d.N.TRANSPARENT_NO_SSAO_DEPTH,e=>e===a.V.LinearDepth&&this.parameters.writeLinearDepth&&this._isTransparent&&this.parameters.writeDepth],[d.N.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL,e=>((0,a.BF)(e)||e===a.V.LinearDepth&&this.parameters.writeLinearDepth)&&this._isTransparent&&!this.parameters.writeDepth],[d.N.DRAPED_MATERIAL,e=>(0,a.i3)(e)]]),this._configuration=new _}getConfiguration(e,t){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors&&!this.parameters.vvColor,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this._isTransparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.enableOffset=t.camera.relativeElevation<c.xt,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.draped=this.parameters.draped,this._configuration}createGLMaterial(e){return new z(e)}createBufferWriter(){const e=(0,r.BP)().vec3f(p.r.POSITION);return(0,o.A)("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(p.r.OBJECTANDLAYERIDCOLOR),this.parameters.vvColor?e.f32(p.r.COLORFEATUREATTRIBUTE):e.vec4u8(p.r.COLOR),new u.Z(e)}get _isTransparent(){return this.parameters.color[3]<1||this.parameters.forceTransparentMode}}class z extends l.A{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==a.V.Color&&this._output!==a.V.Alpha||this._updateOccludeeState(e),this.ensureTechnique(b,e)}}class D extends h.S{constructor(){super(...arguments),this.color=i.uY,this.forceTransparentMode=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=s.s2.None,this.hasOccludees=!1,this.draped=!1}}},84248:(e,t,n)=>{n.d(t,{R:()=>Y});var o=n(81806),i=n(15941),r=n(63919),a=n(44680),s=n(34761),l=n(13191),c=n(72745),d=n(20664),p=n(9392),u=n(55855);function f(e){return function(e){return e instanceof Float32Array&&e.length>=16}(e)||function(e){return Array.isArray(e)&&e.length>=16}(e)}var h=n(2413),v=n(88105),g=n(63048),m=n(22955),y=n(48549),A=n(34981),O=n(40318),x=n(75803),C=n(45463),b=n(77730),S=n(12028),P=n(86994),w=n(66470),T=n(96791),_=n(52757),E=n(99362),z=n(19061),D=n(64465),V=n(16506),H=n(42693),R=n(32119),I=n(60322),N=n(28584),j=n(10773),F=n(93345),L=n(57162);class U extends H.w{initializeConfiguration(e,t){t.spherical=e.viewingMode===D.RT.Global}initializeProgram(e){return new N.B(e.rctx,U.shader.get().build(this.configuration),R.D)}initializePipeline(){const e=this.configuration.transparencyPassType,t=this.configuration,n=e===j.y.NONE,o=e===j.y.FrontFace,i=this.configuration.hasPolygonOffset?W:null,r=t.draped?null:(n||o)&&t.output!==A.V.Highlight&&(t.depthEnabled||t.occlusionPass)?L.kn:null;return(0,L.Ey)({blending:t.output===A.V.Color||t.output===A.V.Alpha||t.output===A.V.Highlight?n?M:(0,I.ez)(e):null,depthTest:t.draped?null:{func:F.MT.LEQUAL},depthWrite:r,colorWrite:L.wE,polygonOffset:i})}get primitiveType(){return this.configuration.occlusionPass?F.WR.POINTS:F.WR.TRIANGLES}}U.shader=new V.$(z.H,(()=>n.e(60271).then(n.bind(n,60271))));const W={factor:0,units:-4},M=(0,L.ox)(F.dn.ONE,F.dn.ONE_MINUS_SRC_ALPHA);var B=n(35143),G=n(99415),k=n(92656);class q extends k.E{constructor(){super(...arguments),this.output=A.V.Color,this.transparencyPassType=j.y.NONE,this.screenCenterOffsetUnitsEnabled=!1,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}(0,B._)([(0,G.W)({count:A.V.COUNT})],q.prototype,"output",void 0),(0,B._)([(0,G.W)({count:j.y.COUNT})],q.prototype,"transparencyPassType",void 0),(0,B._)([(0,G.W)()],q.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"spherical",void 0),(0,B._)([(0,G.W)()],q.prototype,"occlusionTestEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"signedDistanceFieldEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),(0,B._)([(0,G.W)()],q.prototype,"vvSize",void 0),(0,B._)([(0,G.W)()],q.prototype,"vvColor",void 0),(0,B._)([(0,G.W)()],q.prototype,"hasVerticalOffset",void 0),(0,B._)([(0,G.W)()],q.prototype,"hasScreenSizePerspective",void 0),(0,B._)([(0,G.W)()],q.prototype,"debugDrawLabelBorder",void 0),(0,B._)([(0,G.W)()],q.prototype,"hasSlicePlane",void 0),(0,B._)([(0,G.W)()],q.prototype,"hasPolygonOffset",void 0),(0,B._)([(0,G.W)()],q.prototype,"depthEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"pixelSnappingEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"draped",void 0),(0,B._)([(0,G.W)()],q.prototype,"multipassEnabled",void 0),(0,B._)([(0,G.W)()],q.prototype,"cullAboveGround",void 0),(0,B._)([(0,G.W)()],q.prototype,"occlusionPass",void 0),(0,B._)([(0,G.W)()],q.prototype,"objectAndLayerIdColorInstanced",void 0),(0,B._)([(0,G.W)({constValue:!0})],q.prototype,"hasSliceInVertexProgram",void 0),(0,B._)([(0,G.W)({constValue:!1})],q.prototype,"hasVvInstancing",void 0);class Y extends C.im{constructor(e){super(e,new fe),this._configuration=new q,this.produces=new Map([[b.N.HUD_MATERIAL,e=>(0,A.L0)(e)&&!this.parameters.drawInSecondSlot],[b.N.LABEL_MATERIAL,e=>(0,A.L0)(e)&&this.parameters.drawInSecondSlot],[b.N.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[b.N.DRAPED_MATERIAL,e=>(0,A.L0)(e)]])}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===b.N.OCCLUSION_PIXELS&&this.parameters.occlusionTest,e===A.V.Color&&(this._configuration.debugDrawLabelBorder=!!m.b.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,n,o,i,a){if(!(n.options.selectionMode&&n.options.hud&&e.visible&&n.point))return;const l=this.parameters,c=n.point,u=n.camera;let{scaleX:f,scaleY:h}=this._getScreenScale(e);f*=u.pixelRatio,h*=u.pixelRatio,(0,r.z0)(ne,t),e.attributes.has(w.r.FEATUREATTRIBUTE)&&function(e){const t=e[0],n=e[1],o=e[2],i=e[3],r=e[4],a=e[5],s=e[6],l=e[7],c=e[8],d=1/Math.sqrt(t*t+n*n+o*o),p=1/Math.sqrt(i*i+r*r+a*a),u=1/Math.sqrt(s*s+l*l+c*c);e[0]=t*d,e[1]=n*d,e[2]=o*d,e[3]=i*p,e[4]=r*p,e[5]=a*p,e[6]=s*u,e[7]=l*u,e[8]=c*u}(ne);const v=e.attributes.get(w.r.POSITION),g=e.attributes.get(w.r.SIZE),m=e.attributes.get(w.r.NORMAL),y=e.attributes.get(w.r.CENTEROFFSETANDDISTANCE);(0,P.vA)(v.size>=3);const A=(0,z.c)(l),O="screen"===this.parameters.centerOffsetUnits;for(let r=0;r<v.data.length/v.size;r++){const e=r*v.size;(0,d.s)(J,v.data[e],v.data[e+1],v.data[e+2]),(0,d.e)(J,J,t);const o=r*g.size;pe[0]=g.data[o]*f,pe[1]=g.data[o+1]*h,(0,d.e)(J,J,u.viewMatrix);const i=r*y.size;if((0,d.s)(re,y.data[i],y.data[i+1],y.data[i+2]),!O&&(J[0]+=re[0],J[1]+=re[1],0!==re[2])){const e=re[2];(0,d.n)(re,J),(0,d.f)(J,J,(0,d.h)(re,re,e))}const x=r*m.size;if((0,d.s)($,m.data[x],m.data[x+1],m.data[x+2]),this._normalAndViewAngle($,ne,u,le),this._applyVerticalOffsetTransformationView(J,le,u,X),u.applyProjection(J,K),K[0]>-1){O&&(re[0]||re[1])&&(K[0]+=re[0]*u.pixelRatio,0!==re[1]&&(K[1]+=(0,S.m0)(re[1],X.factorAlignment)*u.pixelRatio),u.unapplyProjection(K,J)),K[0]+=this.parameters.screenOffset[0]*u.pixelRatio,K[1]+=this.parameters.screenOffset[1]*u.pixelRatio,K[0]=Math.floor(K[0]),K[1]=Math.floor(K[1]),(0,S.MD)(pe,X.factor,pe);const e=ce*u.pixelRatio;let t=0;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*u.pixelRatio/2),Z(c,K[0],K[1],pe,e,t,l,A)){const e=n.ray;if((0,d.e)(te,J,(0,s.B8)(ie,u.viewMatrix)),K[0]=c[0],K[1]=c[1],u.unprojectFromRenderScreen(K,J)){const t=(0,p.vt)();(0,d.c)(t,e.direction);const n=1/(0,d.l)(t);(0,d.h)(t,t,n),a((0,d.q)(e.origin,J)*n,t,-1,!0,1,te)}}}}}intersectDraped(e,t,n,o,i,r){const a=e.attributes.get(w.r.POSITION),s=e.attributes.get(w.r.SIZE),l=this.parameters,c=(0,z.c)(l);let{scaleX:d,scaleY:p}=this._getScreenScale(e);d*=e.screenToWorldRatio,p*=e.screenToWorldRatio;const u=de*e.screenToWorldRatio;for(let f=0;f<a.data.length/a.size;f++){const t=f*a.size,n=a.data[t],h=a.data[t+1],v=f*s.size;pe[0]=s.data[v]*d,pe[1]=s.data[v+1]*p;let g=0;l.textureIsSignedDistanceField&&(g=l.outlineSize*e.screenToWorldRatio/2),Z(o,n,h,pe,u,g,l,c)&&i(r.dist,r.normal,-1,!1)}}createBufferWriter(){return new ge(this)}_normalAndViewAngle(e,t,n,o){return f(t)&&(t=(0,r.z0)(oe,t)),(0,d.t)(o.normal,e,t),(0,d.e)(o.normal,o.normal,n.viewInverseTransposeMatrix),o.cosAngle=(0,d.k)(ee,ue),o}_updateScaleInfo(e,t,n){const o=this.parameters;null!=o.screenSizePerspective?(0,S.cJ)(n,t,o.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),null!=o.screenSizePerspectiveAlignment?(0,S.cJ)(n,t,o.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,n,o,i,r,a){const s=this._normalAndViewAngle(t,n,i,le);return this._applyVerticalGroundOffsetView(e,s,i,a),this._applyVerticalOffsetTransformationView(a,s,i,r),this._applyPolygonOffsetView(a,s,o[3],i,a),this._applyCenterOffsetView(a,o,a),a}applyShaderOffsetsNDC(e,t,n,o,i){return this._applyCenterOffsetNDC(e,t,n,o),null!=i&&(0,d.c)(i,o),this._applyPolygonOffsetNDC(o,t,n,o),o}_applyPolygonOffsetView(e,t,n,o,r){const a=o.aboveGround?1:-1;let s=Math.sign(n);0===s&&(s=a);const l=a*s;if(this.parameters.shaderPolygonOffset<=0)return(0,d.c)(r,e);const c=(0,i.qE)(Math.abs(t.cosAngle),.01,1),p=1-Math.sqrt(1-c*c)/c/o.viewport[2];return(0,d.h)(r,e,l>0?p:1/p),r}_applyVerticalGroundOffsetView(e,t,n,o){const i=(0,d.l)(e),r=n.aboveGround?1:-1,a=n.computeRenderPixelSizeAtDist(i)*O.R,s=(0,d.h)(J,t.normal,r*a);return(0,d.g)(o,e,s),o}_applyVerticalOffsetTransformationView(e,t,n,o){var i,r;const a=this.parameters;if(null===(i=a.verticalOffset)||void 0===i||!i.screenLength){if(a.screenSizePerspective||a.screenSizePerspectiveAlignment){const n=(0,d.l)(e);this._updateScaleInfo(o,n,t.cosAngle)}else o.factor.scale=1,o.factorAlignment.scale=1;return e}const s=(0,d.l)(e),l=null!==(r=a.screenSizePerspectiveAlignment)&&void 0!==r?r:a.screenSizePerspective,c=(0,E.kE)(n,s,a.verticalOffset,t.cosAngle,l);return this._updateScaleInfo(o,s,t.cosAngle),(0,d.h)(t.normal,t.normal,c),(0,d.g)(e,e,t.normal)}_applyCenterOffsetView(e,t,n){const o="screen"!==this.parameters.centerOffsetUnits;return n!==e&&(0,d.c)(n,e),o&&(n[0]+=t[0],n[1]+=t[1],t[2]&&((0,d.n)($,n),(0,d.g)(n,n,(0,d.h)($,$,t[2])))),n}_applyCenterOffsetNDC(e,t,n,o){const i="screen"!==this.parameters.centerOffsetUnits;return o!==e&&(0,d.c)(o,e),i||(o[0]+=t[0]/n.fullWidth*2,o[1]+=t[1]/n.fullHeight*2),o}_applyPolygonOffsetNDC(e,t,n,o){const i=this.parameters.shaderPolygonOffset;if(e!==o&&(0,d.c)(o,e),i){const e=n.aboveGround?1:-1,r=e*Math.sign(t[3]);o[2]-=(r||e)*i}return o}createGLMaterial(e){return new Q(e)}calculateRelativeScreenBounds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:(0,h.vt)();return function(e,t,n,o){o[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*n,o[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*n}(this.parameters,e,t,n),n[2]=n[0]+e[0],n[3]=n[1]+e[1],n}_getScreenScale(e){const t=e.attributes.get(w.r.FEATUREATTRIBUTE);if(null==t)return{scaleX:1,scaleY:1};const n=(0,u.ci)(t.data,se),[o,i]=(0,g.VC)(ae,this.parameters,n);return{scaleX:o,scaleY:i}}}class Q extends x.m{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(U,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function Z(e,t,n,o,i,r,a,s){let l=t-i-(s[0]>0?o[0]*s[0]:0),c=l+o[0]+2*i,d=n-i-(s[1]>0?o[1]*s[1]:0),p=d+o[1]+2*i;const u=a.distanceFieldBoundingBox;return a.textureIsSignedDistanceField&&null!=u&&(l+=o[0]*u[0],d+=o[1]*u[1],c-=o[0]*(1-u[2]),p-=o[1]*(1-u[3]),l-=r,c+=r,d-=r,p+=r),e[0]>l&&e[0]<c&&e[1]>d&&e[1]<p}const X=new T.D,J=(0,p.vt)(),$=(0,p.vt)(),K=(0,u.vt)(),ee=(0,p.vt)(),te=(0,p.vt)(),ne=(0,a.vt)(),oe=(0,a.vt)(),ie=(0,l.vt)(),re=(0,p.vt)(),ae=(0,p.vt)(),se=(0,u.vt)(),le={normal:ee,cosAngle:0},ce=1,de=2,pe=[0,0],ue=(0,p.fA)(0,0,1);class fe extends x.N{constructor(){super(...arguments),this.renderOccluded=C.m$.Occlude,this.isDecoration=!1,this.color=(0,u.fA)(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=(0,c.fA)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=(0,u.fA)(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.draped=!1}}const he=(0,y.BP)().vec3f(w.r.POSITION).vec3f(w.r.NORMAL).vec2f(w.r.UV0).vec4u8(w.r.COLOR).vec2f(w.r.SIZE).vec4f(w.r.CENTEROFFSETANDDISTANCE).vec4f(w.r.FEATUREATTRIBUTE),ve=he.clone().vec4u8(w.r.OBJECTANDLAYERIDCOLOR);class ge{constructor(e){this._material=e,this.vertexBufferLayout=(0,o.A)("enable-feature:objectAndLayerId-rendering")?ve:he}elementCount(e){return 6*e.attributes.get(w.r.POSITION).indices.length}write(e,t,n,o,i){(0,_.Hk)(n.attributes.get(w.r.POSITION),e,o.position,i,6),(0,_.p1)(n.attributes.get(w.r.NORMAL),t,o.normal,i,6);const r=n.attributes.get(w.r.UV0).data;let a,s,l,c;if(null==r||r.length<4){const e=this._material.parameters;a=0,s=0,l=e.texCoordScale[0],c=e.texCoordScale[1]}else a=r[0],s=r[1],l=r[2],c=r[3];l=Math.min(1.99999,l+1),c=Math.min(1.99999,c+1);let d=n.attributes.get(w.r.POSITION).indices.length,p=i;const u=o.uv0;for(let v=0;v<d;++v)u.set(p,0,a),u.set(p,1,s),p++,u.set(p,0,l),u.set(p,1,s),p++,u.set(p,0,l),u.set(p,1,c),p++,u.set(p,0,l),u.set(p,1,c),p++,u.set(p,0,a),u.set(p,1,c),p++,u.set(p,0,a),u.set(p,1,s),p++;(0,_.tb)(n.attributes.get(w.r.COLOR),4,o.color,i,6);const{data:f,indices:h}=n.attributes.get(w.r.SIZE);d=h.length;const g=o.size;p=i;for(let v=0;v<d;++v){const e=f[2*h[v]],t=f[2*h[v]+1];for(let n=0;n<6;++n)g.set(p,0,e),g.set(p,1,t),p++}if(n.attributes.get(w.r.CENTEROFFSETANDDISTANCE)?(0,_.Ut)(n.attributes.get(w.r.CENTEROFFSETANDDISTANCE),o.centerOffsetAndDistance,i,6):(0,_.Pq)(o.centerOffsetAndDistance,i,6*d),n.attributes.get(w.r.FEATUREATTRIBUTE)?(0,_.Ut)(n.attributes.get(w.r.FEATUREATTRIBUTE),o.featureAttribute,i,6):(0,_.Pq)(o.featureAttribute,i,6*d),null!=n.objectAndLayerIdColor){var m;const e=null===(m=n.attributes.get(w.r.POSITION))||void 0===m?void 0:m.indices;if(e){const t=e.length,r=o.getField(w.r.OBJECTANDLAYERIDCOLOR,v.XP);(0,_.tH)(n.objectAndLayerIdColor,r,t,i,6)}}}}},96791:(e,t,n)=>{n.d(t,{D:()=>o});class o{constructor(){this.factor=new i,this.factorAlignment=new i}}class i{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}},63928:(e,t,n)=>{n.d(t,{W:()=>r});var o=n(45463),i=n(99362);class r extends o.im{intersect(e,t,n,o,r,a){return(0,i.Uy)(e,n,o,r,void 0,a)}}}}]);
//# sourceMappingURL=70177.7e3a4844.chunk.js.map